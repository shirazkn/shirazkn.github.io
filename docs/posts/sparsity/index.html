<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Sparsity | Shiraz</title>
<meta name="keywords" content="Linear Algebra, Optimization">
<meta name="description" content="The so called curse of dimensionality in machine learning is the observation that neural networks with many parameters can be impossibly difficult to train due to the vastness of its parameter space. This is because many (if not all) of the problems we&rsquo;re interested in solving as engineers have some inherent sparsity.">
<meta name="author" content="">
<link rel="canonical" href="https://shirazkn.github.io/posts/sparsity/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e150a9308943c96db7a04da2d3c2cfc65f8f6bdf60a8495e630a39fd37bfaf93.css" integrity="sha256-4VCpMIlDyW23oE2i08LPxl&#43;Pa99gqEleYwo5/Te/r5M=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://shirazkn.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://shirazkn.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://shirazkn.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://shirazkn.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://shirazkn.github.io/favicon.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://shirazkn.github.io/posts/sparsity/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><script>
(function() {
    var pref = localStorage.getItem("pref-theme");
    if (pref === "dark" || (!pref && window.matchMedia("(prefers-color-scheme: dark)").matches)) {
        document.documentElement.classList.add("dark");
    }
})();
</script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      packages: {'[+]': ['mathtools', 'amscd']},
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    },
    loader:{
      load: ['ui/safe', '[tex]/mathtools', '[tex]/amscd']
    },
  };
</script>

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IM+Fell+DW+Pica">

<meta property="og:url" content="https://shirazkn.github.io/posts/sparsity/">
  <meta property="og:site_name" content="Shiraz">
  <meta property="og:title" content="Sparsity">
  <meta property="og:description" content="The so called curse of dimensionality in machine learning is the observation that neural networks with many parameters can be impossibly difficult to train due to the vastness of its parameter space. This is because many (if not all) of the problems we’re interested in solving as engineers have some inherent sparsity.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-22T11:05:58-04:00">
    <meta property="article:modified_time" content="2023-04-22T11:05:58-04:00">
    <meta property="article:tag" content="Linear Algebra">
    <meta property="article:tag" content="Optimization">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sparsity">
<meta name="twitter:description" content="The so called curse of dimensionality in machine learning is the observation that neural networks with many parameters can be impossibly difficult to train due to the vastness of its parameter space. This is because many (if not all) of the problems we&rsquo;re interested in solving as engineers have some inherent sparsity.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://shirazkn.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Sparsity",
      "item": "https://shirazkn.github.io/posts/sparsity/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sparsity",
  "name": "Sparsity",
  "description": "The so called curse of dimensionality in machine learning is the observation that neural networks with many parameters can be impossibly difficult to train due to the vastness of its parameter space. This is because many (if not all) of the problems we\u0026rsquo;re interested in solving as engineers have some inherent sparsity.",
  "keywords": [
    "Linear Algebra", "Optimization"
  ],
  "articleBody": "The so called curse of dimensionality in machine learning is the observation that neural networks with many parameters can be impossibly difficult to train due to the vastness of its parameter space. Another issue that arises in practice is that most of the neural network does not do anything, as a lot of its weights turn out to be redundant. This is because many (if not all) of the problems we’re interested in solving as engineers have some inherent sparsity. Steve Brunton has an excellent video explaining why this is so.\nAs a shorthand, the word ‘sparse’ means ‘mostly zeros’. Here is a sparse vector:\n\\[x^{\\intercal}=[0\\ 3\\ 5\\ 0\\ 0\\ 1\\ 0\\ \\dots\\ 0\\ 8\\ 0]^{\\intercal}\\] Often, you might need to transform the original object into another domain, before the object looks sparse. As an example, the function $\\sin(t)$ is sparse in the frequency domain (it only has a single frequency component) but is non-sparse in the time domain, because $\\sin(t)\\neq 0$ for most values of $t$. The Fourier transform lets us move back and forth between the original and sparse domains. A lot of high-dimensional data transfer (like streaming videos, talking on Zoom) relies on exploiting the sparsity of the information, if not in the frequency domain, then in some other form. (See the post on Hilbert spaces for a more general treatment.)\nCompressive Sensing A field of research that blew up in the $2000$s is compressive sensing, in which a recurring theme is the following observation. Suppose you want to solve the problem $Ax=b$; you know $A$ and $b$, but not $x$. We call this a system of equations. It is a high-school math fact that exactly one of the following is true:\nthere is a unique $x$ such that $Ax=b$ there is no $x$ such that $Ax=b$ (overdetermined and inconsistent system of equations) there are infinitely many $x$’s such that $Ax=b$ (underdetermined system of equations) The last case arises when $A\\in \\mathbb R^{m\\times n}$ is a ‘wide’ matrix, with $n\u003em$. This automatically means that $A$ has a non-trivial nullspace (or kernel)1, and for any $v\\in \\ker(A)$, $A(x+v)=Ax$. So we can construct infinitely many solutions this way.\nOne reason for solving $Ax=b$ might be because $b$ are the measurements that we have of an unknown vector $x$; $A$ is called the measurement matrix. If $n\\gg m$, it means that we have far fewer measurements than unknowns (underdetermined system of equations). The theory of compressive sensing says that it is still possible to recover $x$ uniquely if the solution is known to be sparse.2 And as we mentioned, the solution oftentimes is sparse. Instead of solving $Ax=b$, we can solve\n\\[\\begin{array}{ll} \\underset{x\\in\\mathbb R^n}{\\textrm{minimize}} \u0026\\|x\\|_0\\\\ \\textrm{subject to} \u0026 Ax = b \\end{array} \\] which picks out the sparsest solution (in terms of the number of $0$’s in $x$). The notation ‘$\\vert x\\vert_0$’ is introduced here . In this way, we can uniquely reconstruct $x$ with a comically small number of measurements. (In fact, it can even beat the Nyquist sampling theorem .) The simple trick of searching for sparse solutions now allows us to do things like MRI imaging much more efficiently.\nWhy are sparse solutions special? So why is it that among the infinitely many solutions of $Ax=b$, the sparsest solution turns out to be precisely the solution we were looking for?\nSuppose $A\\in \\mathbb R^{m \\times n}$, $m\\leq n$, and $\\textrm{Rank}(A)$ is its rank. We know that $r = n- \\textrm{Rank}(A)$ is the dimension of its nullspace (see the rank-nullity theorem ). Then, the space of the solutions of $Ax=b$ is $r$-dimensional. Moreover, $r\\geq n-m$ since $\\textrm{Rank}(A)\\leq m$. So if we have too few measurements (i.e., a small value of $m$) then the space of solutions is rather large.\nNow suppose we know that the true solution $x$ is $s$-sparse, i.e., it has at most $s$ non-zero elements. There are $\\binom{n}{s}$ ways of choosing where these non-zero elements may appear. Each choice of the location of the non-zero elements (called as the support of $x$) defines an $s$-dimensional subspace. The space of $s$-sparse vectors is the union of these $s$-dimensional spaces. For e.g., let $n=3$ and $s=2$, then the $2$-sparse vectors in $\\mathbb R^3$ are\n\\[\\textrm{span}\\big(\\lbrace [1\\ 0\\ 0]^{\\intercal}, [0\\ 1\\ 0]^{\\intercal}\\rbrace\\big)\\ \\cup\\ \\textrm{span}\\big(\\lbrace [1\\ 0\\ 0]^{\\intercal}, [0\\ 0\\ 1]^{\\intercal}\\rbrace\\big)\\\\ \\cup \\ \\textrm{span}\\big(\\lbrace [0\\ 1\\ 0]^{\\intercal}, [0\\ 0\\ 1]^{\\intercal}\\rbrace\\big) \\] Unions of two subspaces is much smaller than the $\\textrm{span}$ of them. The set of all $1$-sparse vectors in $\\mathbb R^n$ is the union of the axes or the standard basis vectors of $\\mathbb R^n$, but the axes obviously span the whole space. Thus, even when $n\\gg m$, we can intersect this large $r$-dimensional space of solutions with the tiny $s$-dimensional slices to find the special, sparse solutions of $Ax=b$.\nIn the next post , I talk about why we can also swap $\\lVert x\\rVert_0$ out for $\\lVert x\\rVert_1$ in practice, and still recover $x$ uniquely and perfectly in many cases. Minimization of $\\lVert x\\rVert_0$ is a combinatorial problem (which means that the computational effort required to solve it scales exponentially in the dimension of the problem), but minimization of $\\lVert x\\rVert_1$ is a convex optimization problem, which admits efficient, scalable algorithms for solving it.\nUse the rank-nullity theorem, and the fact that $\\textrm{Rank}(A)\\leq \\textrm{min}\\\\;\\lbrace m,n\\rbrace$ for $A\\in\\mathbb R^{m\\times n}$. ↩︎\nIn addition, $A$ needs to satisfy one of certain properties, such as the restricted isometry property. It essentially ensures that the measurements are somewhat orthogonal to each other, i.e., that we aren’t wasting the few measurements we do have by making redundant measurements. ↩︎\n",
  "wordCount" : "925",
  "inLanguage": "en",
  "datePublished": "2023-04-22T11:05:58-04:00",
  "dateModified": "2023-04-22T11:05:58-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shirazkn.github.io/posts/sparsity/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shiraz",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shirazkn.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://shirazkn.github.io/" accesskey="h" title="Shiraz (Alt + H)">Shiraz</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://shirazkn.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://shirazkn.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://shirazkn.github.io/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Sparsity
    </h1>
    <div class="post-meta"><span title='2023-04-22 11:05:58 -0400 EDT'>April 22, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>The so called <a href="/posts/balls" class="accented">
    curse of dimensionality
</a> in machine learning is the observation that neural networks with many parameters can be impossibly difficult to train due to the vastness of its parameter space. Another issue that arises in practice is that most of the neural network does not do anything, as a lot of its weights turn out to be redundant.
This is because many (if not all) of the problems we&rsquo;re interested in solving as engineers have some inherent <span class=accented>sparsity</span>. Steve Brunton has an <a href="https://www.youtube.com/watch?v=Dt2WYkqZfbs" target="_blank" class="accented">
    excellent video
</a> explaining why this is so.</p>
<p>As a shorthand, the word &lsquo;sparse&rsquo; means &lsquo;mostly zeros&rsquo;. Here is a sparse vector:</p>
<p>
\[x^{\intercal}=[0\ 3\  5\ 0\ 0\  1\ 0\ \dots\ 0\ 8\ 0]^{\intercal}\]
</p>
<p>Often, you might need to transform the original object into another domain, before the object looks sparse. As an example, the function $\sin(t)$ is sparse in the frequency domain (it only has a single frequency component) but is non-sparse in the time domain, because $\sin(t)\neq 0$ for most values of $t$.
The Fourier transform lets us move back and forth between the  original and sparse domains. A lot of high-dimensional data transfer (like streaming videos, talking on Zoom) relies on exploiting the <span class=accented>sparsity</span> of the information, if not in the frequency domain, then in some other form. (See the post on <a href="/posts/hilbert-spaces" class="accented">
    Hilbert spaces
</a> for a more general treatment.)</p>
<h3 id="compressive-sensing">Compressive Sensing<a hidden class="anchor" aria-hidden="true" href="#compressive-sensing">#</a></h3>
<p>A field of research that blew up in the $2000$s is <em>compressive sensing</em>, in which a recurring theme is the following observation. Suppose you want to solve the problem $Ax=b$; you know $A$ and $b$, but not $x$. We call this a <em>system of equations</em>. It is a high-school math fact that exactly one of the following is true:</p>
<ul>
<li>there is a unique $x$ such that $Ax=b$</li>
<li>there is no $x$ such that $Ax=b$ (<span class=accented>overdetermined</span> and inconsistent system of equations)</li>
<li>there are infinitely many $x$&rsquo;s such that $Ax=b$ (<span class=accented>underdetermined</span> system of equations)</li>
</ul>
<p>The last case arises when $A\in \mathbb R^{m\times n}$ is a &lsquo;wide&rsquo; matrix, with $n>m$. This automatically means that $A$ has a non-trivial nullspace (or kernel)<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, and for any $v\in \ker(A)$, $A(x+v)=Ax$. So we can construct infinitely many solutions this way.</p>
<p>One reason for solving $Ax=b$ might be because $b$ are the measurements that we have of an unknown vector $x$; $A$ is called the measurement matrix. If $n\gg m$, it means that we have far fewer measurements than unknowns (underdetermined system of equations). The theory of compressive sensing says that <span class=accented>it is still possible to recover $x$ uniquely if the solution is known to be sparse</span>.<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> And as we mentioned, the solution oftentimes <em>is</em> sparse.
Instead of solving $Ax=b$, we can solve</p>
<p>
\[\begin{array}{ll}
\underset{x\in\mathbb R^n}{\textrm{minimize}} &\|x\|_0\\
\textrm{subject to} & Ax = b
\end{array}
\]
</p>
<p>which picks out the sparsest solution (in terms of the number of $0$&rsquo;s in $x$). The notation &lsquo;$\vert x\vert_0$&rsquo; is introduced <a href="/posts/norms_metrics" class="accented">
    here
</a>.
In this way, we can uniquely reconstruct $x$ with a comically small number of measurements. (In fact, it can even beat the <a href="https://en.wikipedia.org/wiki/Nyquist%e2%80%93Shannon_sampling_theorem" target="_blank" class="accented">
    Nyquist sampling theorem
</a>.) The simple trick of searching for sparse solutions now allows us to do things like MRI imaging much more efficiently.</p>
<h3 id="why-are-sparse-solutions-special">Why are sparse solutions special?<a hidden class="anchor" aria-hidden="true" href="#why-are-sparse-solutions-special">#</a></h3>
<p>So why is it that among the infinitely many solutions of $Ax=b$, the sparsest solution turns out to be precisely the solution we were looking for?</p>
<p>Suppose $A\in \mathbb R^{m \times n}$, $m\leq n$, and $\textrm{Rank}(A)$ is its rank. We know that $r = n- \textrm{Rank}(A)$ is the dimension of its nullspace (see the <a href="https://en.wikipedia.org/wiki/Rank%e2%80%93nullity_theorem" target="_blank" class="accented">
    rank-nullity theorem
</a>). Then, the space of the solutions of $Ax=b$ is $r$-dimensional. Moreover, $r\geq n-m$ since $\textrm{Rank}(A)\leq m$. So if we have too few measurements (i.e., a small value of $m$) then the space of solutions is rather large.</p>
<p>Now suppose we know that the <em>true</em> solution $x$ is $s$-sparse, i.e., it has at most $s$ non-zero elements. There are $\binom{n}{s}$ ways of choosing where these non-zero elements may appear. Each choice of the location of the non-zero elements (called as the <em>support</em> of $x$) defines an $s$-dimensional subspace.
The space of $s$-sparse vectors is the <em>union</em> of these $s$-dimensional spaces. For e.g., let $n=3$ and $s=2$, then the $2$-sparse vectors in $\mathbb R^3$ are</p>
<p>
\[\textrm{span}\big(\lbrace [1\ 0\ 0]^{\intercal}, [0\ 1\ 0]^{\intercal}\rbrace\big)\ \cup\  
\textrm{span}\big(\lbrace [1\ 0\ 0]^{\intercal}, [0\ 0\ 1]^{\intercal}\rbrace\big)\\
\cup \ 
\textrm{span}\big(\lbrace [0\ 1\ 0]^{\intercal}, [0\ 0\ 1]^{\intercal}\rbrace\big) 
\]
</p>
<p>Unions of two subspaces is much smaller than the $\textrm{span}$ of them. The set of all $1$-sparse vectors in $\mathbb R^n$ is the union of the axes or the standard basis vectors of $\mathbb R^n$, but the axes obviously <em>span</em> the whole space. Thus, even when $n\gg m$, we can intersect this large $r$-dimensional space of solutions with the tiny $s$-dimensional slices to find the special, sparse solutions of $Ax=b$.</p>
<p>In <a href="/posts/sparsity_2" class="accented">
    the next post
</a>, I talk about why we can also swap $\lVert x\rVert_0$ out for $\lVert x\rVert_1$ in practice, and still recover $x$ uniquely and perfectly in many cases. Minimization of $\lVert x\rVert_0$ is a combinatorial problem (which means that the computational effort required to solve it scales exponentially in the dimension of the problem), but minimization of $\lVert x\rVert_1$ is a <em>convex optimization</em> problem, which admits efficient, scalable algorithms for solving it.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Use the <a href="https://en.wikipedia.org/wiki/Rank%e2%80%93nullity_theorem" target="_blank" class="accented">
    rank-nullity
</a> theorem, and the fact that $\textrm{Rank}(A)\leq \textrm{min}\\;\lbrace m,n\rbrace$ for $A\in\mathbb R^{m\times n}$.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>In addition, $A$ needs to satisfy one of certain properties, such as the <em>restricted isometry property</em>. It essentially ensures that the measurements are somewhat orthogonal to each other, i.e., that we aren&rsquo;t wasting the few measurements we <em>do</em> have by making redundant measurements.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://shirazkn.github.io/tags/linear-algebra/">Linear Algebra</a></li>
      <li><a href="https://shirazkn.github.io/tags/optimization/">Optimization</a></li>
    </ul>
  </footer>
<script src="https://giscus.app/client.js"
        data-repo="shirazkn/shirazkn.github.io"
        data-repo-id="R_kgDOI2VbWw"
        data-category="Announcements"
        data-category-id="DIC_kwDOI2VbW84CWJnt"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="noborder_light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    
    
    
    
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>

function syncDarkClass() {
    const isDark = document.documentElement.dataset.theme === 'dark';
    document.documentElement.classList.toggle('dark', isDark);
    document.body.classList.toggle('dark', isDark);
}
syncDarkClass();


const themeToggle = document.getElementById('theme-toggle');
if (themeToggle) {
    themeToggle.addEventListener('click', () => {
        setTimeout(syncDarkClass, 0);
    });
}


document.querySelectorAll('.logo a, .post-title').forEach(el => {
    el.innerHTML = el.textContent.trim().split(' ').map(word =>
        `<span class="hover-word">${word.split('').map(char =>
            `<span class="hover-letter">${char}</span>`
        ).join('')}</span>`
    ).join(' ');
});


const isDark = () => document.body.classList.contains('dark');
const hoverColors = isDark()
    ? ['#ff51af', '#ff51af', '#f161ac', '#f161ac', '#db327e', '#db327e', '#3b82f6', '#38bdf8']
    : ['#ff51af', '#ff51af', '#e83a89', '#e83a89', '#f542a1', '#d6306f', '#3b9eff', '#00c2ff'];
document.querySelectorAll('.hover-letter').forEach(letter => {
    letter.addEventListener('mouseenter', () => {
        letter.style.color = hoverColors[Math.floor(Math.random() * hoverColors.length)];
    });
    letter.addEventListener('mouseleave', () => {
        letter.style.color = '';
    });
});


const scanElement = (el) => {
    const letters = el.querySelectorAll('.hover-letter');
    letters.forEach((letter, i) => {
        setTimeout(() => {
            letter.style.transition = 'top 0.05s ease-out, color 0s';
            letter.style.color = hoverColors[Math.floor(Math.random() * hoverColors.length)];
            letter.style.top = '-0.08em';
            setTimeout(() => {
                letter.style.transition = '';
                letter.style.color = '';
                letter.style.top = '';
            }, 100);
        }, i * 50);
    });
};

let lastScannedEl = null;
const triggerRandomScan = () => {
    const logos = Array.from(document.querySelectorAll('.logo a'));
    const titles = Array.from(document.querySelectorAll('.post-title'));
    
    const pickLogo = Math.random() < 0.5 && logos.length > 0;
    let elements = pickLogo ? logos : titles;
    
    if (lastScannedEl && elements.length > 1) {
        elements = elements.filter(el => el !== lastScannedEl);
    }
    if (elements.length > 0) {
        const el = elements[Math.floor(Math.random() * elements.length)];
        lastScannedEl = el;
        scanElement(el);
    }
    
    setTimeout(triggerRandomScan, 4000 + Math.random() * 6000);
};


const isHomePage = document.querySelector('.first-entry.home-info') !== null;


const postCards = document.querySelectorAll('.post-entry');
const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;

if (isTouchDevice && window.isSecureContext && 'DeviceOrientationEvent' in window) {
    
    
    let gyroBaselineBeta = null;
    let gyroBaselineGamma = null;
    const GYRO_DRIFT_RATE = 0.012;
    let gyroRafId = null;
    let latestBeta = null, latestGamma = null;
    let cardGyroPermissionRequested = false;

    
    let currentRotateX = 0, currentRotateY = 0;

    
    let cardFocusValues = new Array(postCards.length).fill(0);
    let scrollRafId = null;

    function updateCardFocus() {
        
        if (scrollRafId) return;
        scrollRafId = requestAnimationFrame(() => {
            const viewportHeight = window.innerHeight;
            const scrollY = window.scrollY;
            const docHeight = document.documentElement.scrollHeight;
            const maxScroll = docHeight - viewportHeight;

            
            const scrollProgress = maxScroll > 0 ? scrollY / maxScroll : 0;
            const viewportFocusPoint = viewportHeight * (0.3 + scrollProgress * 0.4);

            postCards.forEach((card, i) => {
                const rect = card.getBoundingClientRect();
                const cardCenter = rect.top + rect.height / 2;

                
                const distance = Math.abs(cardCenter - viewportFocusPoint);
                const maxDistance = viewportHeight * 0.35; 

                
                const linearFocus = Math.max(0, 1 - distance / maxDistance);
                const focus = linearFocus * linearFocus; 
                cardFocusValues[i] = focus;
            });

            applyCardTransforms();
            scrollRafId = null;
        });
    }

    function applyCardTransforms() {
        postCards.forEach((card, i) => {
            const focus = cardFocusValues[i];
            
            const scale = 1 + focus * 0.02;
            
            const gyroScale = 0.3 + focus * 0.7;
            const rotX = currentRotateX * gyroScale;
            const rotY = currentRotateY * gyroScale;
            
            const shadowOpacity = 0.3 + focus * 0.3;
            const shadowBlur = 2 + focus * 4;

            card.style.transform = `perspective(1000px) rotateX(${rotX}deg) rotateY(${rotY}deg) scale(${scale})`;
            card.style.boxShadow = `0 ${1 + focus * 2}px ${shadowBlur}px rgba(0, 0, 0, ${shadowOpacity})`;
        });
    }

    function handleCardOrientation(event) {
        if (event.beta === null || event.gamma === null) return;

        
        const orientation = screen.orientation?.angle ?? window.orientation ?? 0;
        let beta, gamma;

        if (orientation === 90) {
            beta = event.gamma;
            gamma = -event.beta;
        } else if (orientation === -90 || orientation === 270) {
            beta = -event.gamma;
            gamma = event.beta;
        } else if (orientation === 180) {
            beta = -event.beta;
            gamma = -event.gamma;
        } else {
            beta = event.beta;
            gamma = event.gamma;
        }

        latestBeta = beta;
        latestGamma = gamma;

        if (!gyroRafId) {
            gyroRafId = requestAnimationFrame(() => {
                
                if (gyroBaselineBeta === null) {
                    gyroBaselineBeta = latestBeta;
                    gyroBaselineGamma = latestGamma;
                }

                
                gyroBaselineBeta += (latestBeta - gyroBaselineBeta) * GYRO_DRIFT_RATE;
                gyroBaselineGamma += (latestGamma - gyroBaselineGamma) * GYRO_DRIFT_RATE;

                
                let relativeBeta = latestBeta - gyroBaselineBeta;
                let relativeGamma = latestGamma - gyroBaselineGamma;

                
                if (Math.abs(relativeBeta) > 40 || Math.abs(relativeGamma) > 40) {
                    gyroBaselineBeta = latestBeta;
                    gyroBaselineGamma = latestGamma;
                    relativeBeta = 0;
                    relativeGamma = 0;
                }

                
                currentRotateY = Math.max(-8, Math.min(8, relativeGamma * 0.35));
                currentRotateX = Math.max(-8, Math.min(8, relativeBeta * -0.35));

                applyCardTransforms();
                gyroRafId = null;
            });
        }
    }

    function enableCardGyroscope() {
        window.addEventListener('deviceorientation', handleCardOrientation, { passive: true });
    }

    
    window.addEventListener('scroll', updateCardFocus, { passive: true });
    
    updateCardFocus();

    
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        
        enableCardGyroscope();

        
        const requestPermission = () => {
            if (cardGyroPermissionRequested) return;
            cardGyroPermissionRequested = true;

            DeviceOrientationEvent.requestPermission()
                .then(state => {
                    if (state === 'granted') {
                        enableCardGyroscope();
                    }
                })
                .catch(() => {
                    cardGyroPermissionRequested = false;
                });
        };
        document.addEventListener('touchstart', requestPermission, { once: true, passive: true });
        document.addEventListener('touchend', requestPermission, { once: true, passive: true });
        document.addEventListener('click', requestPermission, { once: true, passive: true });
    } else {
        
        enableCardGyroscope();
    }
} else {
    
    postCards.forEach(card => {
        let rafId = null;
        let mouseX = 0, mouseY = 0;

        card.addEventListener('mousemove', (e) => {
            const rect = card.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (!rafId) {
                rafId = requestAnimationFrame(() => {
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const rotateX = (mouseY - centerY) / centerY * -0.8;
                    const rotateY = (mouseX - centerX) / centerX * 0.8;
                    const normalizedY = (centerY - mouseY) / centerY;
                    const isDarkMode = document.body.classList.contains('dark');
                    const baseOpacity = isDarkMode ? 0.35 : 0.15;
                    const opacityRange = isDarkMode ? 0.25 : 0.15;
                    const shadowOpacity = Math.max(0, baseOpacity + normalizedY * opacityRange);
                    const blur = isDarkMode ? 1 : 0.5;
                    card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-1px) scale(1.004)`;
                    card.style.boxShadow = `0 1px ${blur}px rgba(0, 0, 0, ${shadowOpacity})`;
                    rafId = null;
                });
            }
        });
        card.addEventListener('mouseleave', () => {
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            card.style.transform = '';
            card.style.boxShadow = '';
        });
    });
}

if (isHomePage) {
    
    setTimeout(triggerRandomScan, 3000 + Math.random() * 2000);
} else {
    
    setTimeout(() => {
        const logo = document.querySelector('.logo a');
        if (logo) scanElement(logo);

        setTimeout(() => {
            const titles = Array.from(document.querySelectorAll('.post-title'));
            if (titles.length > 0) {
                scanElement(titles[Math.floor(Math.random() * titles.length)]);
            }
            
            setTimeout(triggerRandomScan, 4000 + Math.random() * 6000);
        }, 400);
    }, 800);
}


const tocBox = document.querySelector('.toc');
if (tocBox) {
    const tocDetails = tocBox.querySelector('details');
    if (tocDetails) {
        tocBox.addEventListener('click', (e) => {
            
            if (e.target.tagName === 'A') return;
            
            if (e.target.closest('summary')) return;
            tocDetails.open = !tocDetails.open;
        });
    }
}
</script>
<div class="headerfooter">
    <sub><sup><sub>..</sub></sup></sub>
</div>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            document.documentElement.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            document.documentElement.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
