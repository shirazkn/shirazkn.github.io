<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>The Parallelogram Law | Shiraz</title>
<meta name="keywords" content="Linear Algebra">
<meta name="description" content="I mentioned in the last post that Euclidean geometry arises by taking the real numbers and endowing with an inner product, at which point it satisfies the Pythagoras theorem. In this post I will talk about how the Pythagoras theorem is a special case of a more general feature of inner product spaces.">
<meta name="author" content="">
<link rel="canonical" href="https://shirazkn.github.io/posts/pythagoras/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.714beb9e60d8ed0531b78e01eacc2e1a3e3fb3a790b8452005202c5e4ab1c2ed.css" integrity="sha256-cUvrnmDY7QUxt44B6swuGj4/s6eQuEUgBSAsXkqxwu0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://shirazkn.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://shirazkn.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://shirazkn.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://shirazkn.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://shirazkn.github.io/favicon.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://shirazkn.github.io/posts/pythagoras/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><script>
(function() {
    var pref = localStorage.getItem("pref-theme");
    if (pref === "dark" || (!pref && window.matchMedia("(prefers-color-scheme: dark)").matches)) {
        document.documentElement.classList.add("dark");
    }
})();
</script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      packages: {'[+]': ['mathtools', 'amscd']},
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    },
    loader:{
      load: ['ui/safe', '[tex]/mathtools', '[tex]/amscd']
    },
  };
</script>

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IM+Fell+DW+Pica">

<meta property="og:url" content="https://shirazkn.github.io/posts/pythagoras/">
  <meta property="og:site_name" content="Shiraz">
  <meta property="og:title" content="The Parallelogram Law">
  <meta property="og:description" content="I mentioned in the last post that Euclidean geometry arises by taking the real numbers and endowing with an inner product, at which point it satisfies the Pythagoras theorem. In this post I will talk about how the Pythagoras theorem is a special case of a more general feature of inner product spaces.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-14T15:53:46-04:00">
    <meta property="article:modified_time" content="2023-04-14T15:53:46-04:00">
    <meta property="article:tag" content="Linear Algebra">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Parallelogram Law">
<meta name="twitter:description" content="I mentioned in the last post that Euclidean geometry arises by taking the real numbers and endowing with an inner product, at which point it satisfies the Pythagoras theorem. In this post I will talk about how the Pythagoras theorem is a special case of a more general feature of inner product spaces.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://shirazkn.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "The Parallelogram Law",
      "item": "https://shirazkn.github.io/posts/pythagoras/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "The Parallelogram Law",
  "name": "The Parallelogram Law",
  "description": "I mentioned in the last post that Euclidean geometry arises by taking the real numbers and endowing with an inner product, at which point it satisfies the Pythagoras theorem. In this post I will talk about how the Pythagoras theorem is a special case of a more general feature of inner product spaces.",
  "keywords": [
    "Linear Algebra"
  ],
  "articleBody": "To quote this math podcast , “the real world is a special case”. I mentioned in the last post that Euclidean geometry arises by taking $\\mathbb R^2$ or $\\mathbb R^3$ and endowing with an inner product, at which point it satisfies the Pythagoras theorem. In this post I will talk about how the Pythagoras theorem is a special case of a more general feature of inner product spaces. Contents of the last post are pre-requisites for this one.\nThe Parallelogram Law Let $x$ and $y$ be two vectors in a normed vector space that we are interested in. Recall that the existence of an inner product $\\langle x, y\\rangle$ implies the existence of a corresponding norm, $\\lVert x\\rVert = \\sqrt{\\langle x, x\\rangle}$. But the converse direction is not always true. When it is true, is precisely when the normed vector space obeys the parallelogram law; for all vectors $x$ and $y$,\n\\[2\\|x\\|^2 + 2\\|y\\|^2 = \\|x+y\\|^2 + \\|x-y\\|^2 \\] The name of this law comes from the special case of $\\mathbb R^2$ shown above, where it is a relationship between the side lengths and diagonals of a parallelogram. Notably, if $\\lVert x+y \\rVert=\\lVert x-y \\rVert$, i.e., the parallelogram is a rectangle, then we recover the Pythagoras theorem. Thus, the Pythagoras theorem is a corollary (i.e., a by product) of the fact that $\\mathbb R^2$ equipped with the Euclidean norm $\\lVert{}\\cdot{}\\rVert_2$ satisfies the parallelogram law.\nNext, let’s see why the validity of the parallelogram law coincides with the existence of an inner product.\nSymmetric Bilinear Forms A symmetric bilinear form is a map $\\phi(x,y)$ that takes two vectors $x$ and $y$ of a vector space and gives a real number1, much like an inner product or a metric does. A symmetric bilinear form is symmetric\n\\[ \\phi(x, y) = \\phi(y,x) \\] and bilinear\n\\[ \\phi(x+y, z+w) = \\phi(x,z) + \\phi(x,w) + \\phi(y,z) + \\phi(y,w) \\] which means that it is linear in either argument. As a part of what we require of an inner product in a real vector space, they must be positive-definite symmetric bilinear forms. Positive definite means that $\\phi(x,x)\\geq 0$ and $\\phi(x,x)=0$ $\\Leftrightarrow$ $x=0$.\nNow, if we set $z=x$ and $w=y$ in the above expression, and using the positive-definite, symmetric, and bilinear properties of inner products, we get\n\\[ \\langle x+y, x+y \\rangle = \\langle x,x \\rangle + \\langle x,y \\rangle + \\langle y,x \\rangle + \\langle y,y \\rangle \\] \\[ \\| x+y\\|^2 = \\| x \\|^2 + 2 \\langle x,y \\rangle + \\| y\\|^2 \\] where we used the notation, $\\lVert x\\rVert = \\sqrt{\\langle x, x\\rangle}$. As $(-y)$ is also an element of our vector space, we can repeat the same steps to get\n\\[ \\| x-y\\|^2 = \\| x \\|^2 - 2 \\langle x,y \\rangle + \\| y\\|^2 \\] The sum of the last two equations is the parallelogram law, whereas subtracting the second equation from the first gives us\n\\[ \\langle x,y \\rangle = \\frac{\\|x+y\\|^2 - \\|x-y\\|^2}{4} \\] Observe that we can use the preceding equation as a definition for the inner product in terms of the underlying norm. Thus, normed vector spaces satisfying the parallelogram law have a unique inner product, which is defined as above. What remains to be shown is that this definition of an inner product using a norm, combined with the parallelogram law (which our norm supposedly satisfies), indeed satisfies all of the requirements that the inner product should .\nSpecial Cases Suppose the normed space we were working with was $\\mathbb R^n$ with the $2$-norm, $\\lVert{}\\cdot{}\\rVert_2$, then as one would expect, the unique inner product we get is the dot product for finite-dimensional vectors $x$ and $y$, which we usually write as $x^Ty$ or $x\\cdot y$ in place of the more general notation of $\\langle x, y \\rangle$. Other $p$-norms do not satisfy the parallelogram law, and hence do not have an associated inner product.\nAs we saw, specializing the underlying vector space to $\\mathbb R^2$ makes the parallelogram law a relationship between the sides and diagonals of a parallelogram. Further specializing to the case where $x$ and $y$ make an angle of $90^\\circ$ between each other, i.e., $\\langle x,y\\rangle = 0$, yields the Pythagoras theorem.\nFinally, in $\\mathbb R$, the law takes its most plausible form:\n\\[ (x+y)^2 + (x-y)^2 = 2x^2 + 2y^2 \\] Update: Someone on Mathstodon pointed out to me that what the parallelogram law is really saying is that the norm-squared function $f(x)=\\lVert x\\rVert^2$ is a degree $2$ polynomial. Let’s explore this real quick.\nNotice that a degree $2$ polynomial is characterized by the fact that its second derivative is constant everywhere. Suppose, this constant (which is the Hessian) is $c\\cdot\\mathbf I$, where $c$ is some number and $\\mathbf I$ is the identity matrix. Let’s take the Taylor series expansion of $f$ at $x$, sticking to the Euclidean space $\\mathbb R^n$ for simplicity.\n\\[ f(x+y) = f(x) + f'(x)^T y + \\frac{1}{2} y^Tf''(x)y \\] \\[ \\qquad \\ = f(x) + f'(x)^T y + \\frac{c}{2} f(y) \\] Similarly,\n\\[ f(x-y) = f(x) - f'(x)^T y + \\frac{c}{2} f(y) \\] Adding these,\n\\[ f(x+y) + f(x-y) = 2 f(x) + c f(y) \\] Naturally, we set $c=2$. Thus, we could potentially simplify the parallelogram law to: The norm-squared function is a polynomial of degree $2$, which sounds more fundamental and less arbitrary than the parallelogram law to me, let alone the Pythagoras theorem. But we need to do more work to generalize this math to hold outside of Euclidean spaces.\n… more generally, an element of the field of that vector space, which is $\\mathbb C$ for complex vector spaces, and so on. We can generalize the above discussion to vector spaces over other fields if we were so inclined. ↩︎\n",
  "wordCount" : "954",
  "inLanguage": "en",
  "datePublished": "2023-04-14T15:53:46-04:00",
  "dateModified": "2023-04-14T15:53:46-04:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shirazkn.github.io/posts/pythagoras/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shiraz",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shirazkn.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://shirazkn.github.io/" accesskey="h" title="Shiraz (Alt + H)">Shiraz</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://shirazkn.github.io/archives/" title="archives">
                    <span>archives</span>
                </a>
            </li>
            <li>
                <a href="https://shirazkn.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://shirazkn.github.io/search/" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      The Parallelogram Law
    </h1>
    <div class="post-meta"><span title='2023-04-14 15:53:46 -0400 EDT'>April 14, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>To quote <a href="https://theartofmathematicspodcast.com" target="_blank" class="accented">
    this math podcast
</a>, &ldquo;the real world is a special case&rdquo;. I mentioned in the last post that Euclidean geometry arises by taking $\mathbb R^2$ or $\mathbb R^3$ and endowing with an inner product, at which point it satisfies the Pythagoras theorem.
In this post I will talk about how the <span class=accented>Pythagoras theorem</span> is a special case of a more general feature of inner product spaces. Contents of <a href="/posts/norms_metrics" class="accented">
    the last post
</a> are pre-requisites for this one.</p>
<!-- When I want to think about $1$ dimensional spaces, I'm instead picturing a ruler in my head, or one of those high-school physics problems involving a train moving at constant velocity. -->
<!-- Anyway, now I will generalize the Pythagoras theorem, which in its most common form is a theorem for $\mathbb R^2$. It is more generally a statement about inner product spaces. -->
<!-- # TODO: how do you measure flatness of a space -->
<h3 id="the-parallelogram-law"><a href="https://en.wikipedia.org/wiki/Parallelogram_law" target="_blank" class="accented">
    The Parallelogram Law
</a></h3>
<p>Let $x$ and $y$ be two vectors in a normed vector space that we are interested in.
Recall that the existence of an inner product $\langle x, y\rangle$ implies the existence of a corresponding norm, $\lVert x\rVert = \sqrt{\langle x, x\rangle}$. But the converse direction is not always true.
When it <em>is</em> true, is precisely when the normed vector space obeys the parallelogram law; for all vectors $x$ and $y$,</p>
<p>
\[2\|x\|^2 + 2\|y\|^2 = \|x+y\|^2 + \|x-y\|^2 \]
</p>
<div>
<!-- <figure class=invertible style="max-width: 25%;"> -->
<figure class=invertible>
<img src=/post-images/linear_algebra/parallelogram_1.png>
</figure>
</div>
<p>The name of this law comes from the special case of $\mathbb R^2$ shown above, where it is a relationship between the side lengths and diagonals of a parallelogram. Notably, if $\lVert x+y \rVert=\lVert x-y \rVert$, i.e., the parallelogram is a rectangle, then we recover the Pythagoras theorem. Thus, the Pythagoras theorem is a corollary (i.e., a by product) of the fact that $\mathbb R^2$ equipped with the Euclidean norm $\lVert{}\cdot{}\rVert_2$ satisfies the parallelogram law.</p>
<p>Next, let&rsquo;s see why the validity of the parallelogram law coincides with the existence of an inner product.</p>
<h3 id="symmetric-bilinear-forms">Symmetric Bilinear Forms<a hidden class="anchor" aria-hidden="true" href="#symmetric-bilinear-forms">#</a></h3>
<p>A <span class=accented>symmetric bilinear form</span> is a map $\phi(x,y)$ that takes two vectors $x$ and $y$ of a vector space and gives a real number<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, much like an inner product or a metric does. A symmetric bilinear form is symmetric</p>
<p>
\[
\phi(x, y) = \phi(y,x)
\]
</p>
<p>and bilinear</p>
<p>
\[
\phi(x+y, z+w) = \phi(x,z) + \phi(x,w) + \phi(y,z) + \phi(y,w)
\]
</p>
<!-- The word 'Hermitian' refers to the fact that we're talking about real numbers (recall that Hermitian matrices have real eigenvalues).  -->
<p>which means that it is linear in either argument.
As a part of what we require of an inner product in a real vector space, they must be positive-definite symmetric bilinear forms. Positive definite means that $\phi(x,x)\geq 0$ and $\phi(x,x)=0$ $\Leftrightarrow$ $x=0$.</p>
<p>Now, if we set $z=x$ and $w=y$ in the above expression, and using the positive-definite, symmetric, and bilinear properties of inner products, we get</p>
<p>
\[
    \langle x+y, x+y \rangle = \langle x,x \rangle + \langle x,y \rangle + \langle y,x \rangle + \langle y,y \rangle
\]
\[
   \| x+y\|^2 = \| x \|^2 + 2 \langle x,y \rangle + \| y\|^2
\]
</p>
<p>where we used the notation, $\lVert x\rVert = \sqrt{\langle x, x\rangle}$.
As $(-y)$ is also an element of our vector space, we can repeat the same steps to get</p>
<p>
\[
   \| x-y\|^2 = \| x \|^2 - 2 \langle x,y \rangle + \| y\|^2
\]
</p>
<p>The sum of the last two equations is the parallelogram law, whereas
subtracting the second equation from the first gives us</p>
<p>
\[
   \langle x,y \rangle = \frac{\|x+y\|^2 - \|x-y\|^2}{4}
\]
</p>
<p>Observe that we can use the preceding equation as a <em>definition</em> for the inner product in terms of the underlying norm.
Thus, normed vector spaces satisfying the parallelogram law have a unique inner product, which is defined as above. What remains to be shown is that this definition of an inner product using a norm, combined with the parallelogram law (which our norm supposedly satisfies), indeed <a href="https://mathoverflow.net/questions/123/linearity-of-the-inner-product-using-the-parallelogram-law" target="_blank" class="accented">
    satisfies all of the requirements that the inner product should
</a>.</p>
<h3 id="special-cases">Special Cases<a hidden class="anchor" aria-hidden="true" href="#special-cases">#</a></h3>
<p>Suppose the normed space we were working with was $\mathbb R^n$ with the $2$-norm, $\lVert{}\cdot{}\rVert_2$, then as one would expect, the unique inner product we get is the dot product for finite-dimensional vectors $x$ and $y$, which we usually write as $x^Ty$ or $x\cdot y$ in place of the more general notation of $\langle x, y \rangle$. Other $p$-norms do not satisfy the parallelogram law, and hence do not have an associated inner product.</p>
<p>As we saw, specializing the underlying vector space to $\mathbb R^2$ makes the parallelogram law a relationship between the sides and diagonals of a parallelogram. Further specializing to the case where $x$ and $y$ make an angle of $90^\circ$ between each other, i.e., $\langle x,y\rangle = 0$, yields the Pythagoras theorem.</p>
<p>Finally, in $\mathbb R$, the law takes its most plausible form:</p>
<p>
\[
   (x+y)^2 + (x-y)^2 = 2x^2 + 2y^2
   \]
</p>
<hr>
<p><strong>Update</strong>: Someone on Mathstodon pointed out to me that what the parallelogram law is <em>really</em> saying is that the norm-squared function $f(x)=\lVert x\rVert^2$ is a degree $2$ polynomial. Let&rsquo;s explore this real quick.</p>
<p>Notice that a degree $2$ polynomial is characterized by the fact that its second derivative is constant everywhere. Suppose, this constant (which is the Hessian) is $c\cdot\mathbf I$, where $c$ is some number and $\mathbf I$ is the identity matrix. Let&rsquo;s take the Taylor series expansion of $f$ at $x$, sticking to the Euclidean space $\mathbb R^n$ for simplicity.</p>
<p>
\[
  f(x+y) = f(x) + f'(x)^T y + \frac{1}{2} y^Tf''(x)y \]
  \[ \qquad \ = f(x) + f'(x)^T y + \frac{c}{2} f(y) 
   \]
</p>
<p>Similarly,</p>
<p>
\[
  f(x-y) = f(x) - f'(x)^T y + \frac{c}{2} f(y) 
   \]
</p>
<p>Adding these,</p>
<p>
\[ f(x+y) + f(x-y) = 2 f(x) + c f(y) \]
</p>
<p>Naturally, we set $c=2$. Thus, we could potentially simplify the parallelogram law to: <span class=accented> The norm-squared function is a polynomial of degree $2$</span>, which sounds more fundamental and less arbitrary than the parallelogram law to me, let alone the Pythagoras theorem. But we need to do more work to generalize this math to hold outside of Euclidean spaces.</p>
<!-- Please reach out to me if you have a neat/natural intuition for where the parallelogram law *really* comes from! -->
<!--
### What *is* the Parallelogram Law?

Let's see where this weirdly fundamental feature of Euclidean spaces comes from. If the Euclidean space is so natural and tangible to us, surely there must be a more intuitive explanation for this law. Consider the following picture:

<div>
 <figure class=invertible style="max-width: 25%;">
<figure class=invertible>
<img src=/post-images/linear_algebra/parallelogram_2.png>
</figure>
</div>

Suppose you had to travel from one of the blue points, to the black (white, if you have dark mode on) point, to the other blue point. Then what the parallelogram law is *really* saying that <span class=accented>traveling in straight lines</span> (along $x+y$ and $x-y$) <span class=accented>is faster than taking a roundabout path</span>. To see this, recall that the norm of a vector space defines a distance between points $x$ and $y$, given by $\lVert x - y \rVert$. The total distance of the straight line journey is $\lVert x+y \rVert + \lVert x-y \rVert$.

But what if you traveled along the black lines instead? You would need to travel $\lVert x\rVert$

-->
<!-- It remains to be unpacked in a future post what the parallelogram law is *really* saying. I mean... it doesn't look all that fundamental to me? Does anybody actually use it to define an inner product which isn't already obvious? We know all about dot products, show us something more interesting. -->
<!-- #### But what is the Parallelogram Law *really* saying?

The so called law is really establishing the *flatness* of an affine space.
An affine space is a vector space that has [forgotten its origin](https://ncatlab.org/nlab/show/affine+space), i.e., where you choose to place the origin does not change its structure. -->
<!-- It is a special case of [sesquilinear forms](https://en.wikipedia.org/wiki/Sesquilinear_form) for complex vector spaces.  --><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>&hellip; more generally, an element of the <a href="https://en.wikipedia.org/wiki/Symmetric_bilinear_form" target="_blank" class="accented">
    field
</a> of that vector space, which is $\mathbb C$ for complex vector spaces, and so on. We can generalize the above discussion to vector spaces over other fields if we were so inclined.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://shirazkn.github.io/tags/linear-algebra/">Linear Algebra</a></li>
    </ul>
  </footer>
<script src="https://giscus.app/client.js"
        data-repo="shirazkn/shirazkn.github.io"
        data-repo-id="R_kgDOI2VbWw"
        data-category="Announcements"
        data-category-id="DIC_kwDOI2VbW84CWJnt"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="noborder_light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    
    
    
    
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>

document.addEventListener('touchstart', function() {}, { passive: true });


function syncDarkClass() {
    const isDark = document.documentElement.dataset.theme === 'dark';
    document.documentElement.classList.toggle('dark', isDark);
    document.body.classList.toggle('dark', isDark);
}
syncDarkClass();


const themeToggle = document.getElementById('theme-toggle');
if (themeToggle) {
    themeToggle.addEventListener('click', () => {
        setTimeout(syncDarkClass, 0);
    });
}


document.querySelectorAll('.logo a, .post-title').forEach(el => {
    el.innerHTML = el.textContent.trim().split(' ').map(word =>
        `<span class="hover-word">${word.split('').map(char =>
            `<span class="hover-letter">${char}</span>`
        ).join('')}</span>`
    ).join(' ');
});


const isDark = () => document.body.classList.contains('dark');
const hoverColorsDark = ['#ff51af', '#ff51af', '#f161ac', '#f161ac', '#db327e', '#db327e', '#3b82f6', '#38bdf8'];
const hoverColorsLight = ['#ff51af', '#ff51af', '#e83a89', '#e83a89', '#f542a1', '#d6306f', '#3b9eff', '#00c2ff'];
const getHoverColors = () => isDark() ? hoverColorsDark : hoverColorsLight;
document.querySelectorAll('.hover-letter').forEach(letter => {
    letter.addEventListener('mouseenter', () => {
        const colors = getHoverColors();
        letter.style.color = colors[Math.floor(Math.random() * colors.length)];
    });
    letter.addEventListener('mouseleave', () => {
        letter.style.color = '';
    });
});


let scanInProgress = false;
const scanElement = (el) => {
    if (scanInProgress) return;
    scanInProgress = true;
    const letters = el.querySelectorAll('.hover-letter');
    const colors = getHoverColors();
    const totalTime = letters.length * 50 + 100;
    letters.forEach((letter, i) => {
        setTimeout(() => {
            letter.style.transition = 'top 0.05s ease-out, color 0s';
            letter.style.color = colors[Math.floor(Math.random() * colors.length)];
            letter.style.top = '-0.08em';
            setTimeout(() => {
                letter.style.transition = '';
                letter.style.color = '';
                letter.style.top = '';
            }, 100);
        }, i * 50);
    });
    setTimeout(() => { scanInProgress = false; }, totalTime);
};

let lastScannedEl = null;
const triggerRandomScan = () => {
    const logos = Array.from(document.querySelectorAll('.logo a'));
    const titles = Array.from(document.querySelectorAll('.post-title'));
    
    const pickLogo = Math.random() < 0.5 && logos.length > 0;
    let elements = pickLogo ? logos : titles;
    
    if (lastScannedEl && elements.length > 1) {
        elements = elements.filter(el => el !== lastScannedEl);
    }
    if (elements.length > 0) {
        const el = elements[Math.floor(Math.random() * elements.length)];
        lastScannedEl = el;
        scanElement(el);
    }
    
    setTimeout(triggerRandomScan, 4000 + Math.random() * 6000);
};


const isHomePage = document.querySelector('.first-entry.home-info') !== null;





const CARD_CONFIG = {
    
    hoverLift: 4,
    
    maxRotation: 0.8,
    
    shadowOpacityLight: 0.22,      
    shadowOpacityDark: 0.45,       
    shadowOpacityRange: 0.12,      
    
    shadowBlurBase: 1.5,           
    shadowBlurHover: 2.5,          
    shadowYOffsetBase: 1,          
    shadowYOffsetHover: 2,         
};



const postCards = document.querySelectorAll('.post-entry');
const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;

if (isTouchDevice && window.isSecureContext && 'DeviceOrientationEvent' in window) {
    
    
    let gyroBaselineBeta = null;
    let gyroBaselineGamma = null;
    const GYRO_DRIFT_RATE_MIN = 0.008;
    const GYRO_DRIFT_RATE_MAX = 0.15;
    let gyroRafId = null;
    let latestBeta = null, latestGamma = null;
    let cardGyroPermissionRequested = false;

    
    let currentRotateX = 0, currentRotateY = 0;

    
    let cardFocusValues = new Array(postCards.length).fill(0);
    let transformRafId = null;

    
    function scheduleTransformUpdate() {
        if (transformRafId) return;
        transformRafId = requestAnimationFrame(() => {
            applyCardTransforms();
            transformRafId = null;
        });
    }

    
    const observerThresholds = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
    const cardObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const index = Array.prototype.indexOf.call(postCards, entry.target);
            if (index === -1) return;

            
            const ratio = entry.intersectionRatio;
            
            cardFocusValues[index] = ratio * ratio;
        });
        scheduleTransformUpdate();
    }, {
        threshold: observerThresholds,
        
        rootMargin: '-15% 0px -15% 0px'
    });

    
    postCards.forEach(card => cardObserver.observe(card));

    function applyCardTransforms() {
        
        const baseGyroX = currentRotateX * 0.3;
        const baseGyroY = currentRotateY * 0.3;
        const gyroRangeX = currentRotateX * 0.7;
        const gyroRangeY = currentRotateY * 0.7;

        for (let i = 0; i < postCards.length; i++) {
            const focus = cardFocusValues[i];
            const card = postCards[i];

            
            const rotX = baseGyroX + gyroRangeX * focus;
            const rotY = baseGyroY + gyroRangeY * focus;

            card.style.transform = `perspective(1000px) rotateX(${rotX}deg) rotateY(${rotY}deg) scale(${1 + focus * 0.02})`;
            card.style.boxShadow = `0 ${1 + focus * 2}px ${2 + focus * 4}px rgba(0,0,0,${0.3 + focus * 0.3})`;
            card.style.opacity = 0.25 + focus * 0.75;
        }
    }

    function handleCardOrientation(event) {
        if (event.beta === null || event.gamma === null) return;

        
        const orientation = screen.orientation?.angle ?? window.orientation ?? 0;
        let beta, gamma;

        if (orientation === 90) {
            beta = event.gamma;
            gamma = -event.beta;
        } else if (orientation === -90 || orientation === 270) {
            beta = -event.gamma;
            gamma = event.beta;
        } else if (orientation === 180) {
            beta = -event.beta;
            gamma = -event.gamma;
        } else {
            beta = event.beta;
            gamma = event.gamma;
        }

        latestBeta = beta;
        latestGamma = gamma;

        if (!gyroRafId) {
            gyroRafId = requestAnimationFrame(() => {
                
                if (gyroBaselineBeta === null) {
                    gyroBaselineBeta = latestBeta;
                    gyroBaselineGamma = latestGamma;
                }

                
                const relativeBeta = latestBeta - gyroBaselineBeta;
                const relativeGamma = latestGamma - gyroBaselineGamma;

                
                const maxTilt = Math.max(Math.abs(relativeBeta), Math.abs(relativeGamma));
                const tiltFactor = Math.min(1, maxTilt / 40);
                const driftRate = GYRO_DRIFT_RATE_MIN + tiltFactor * tiltFactor * (GYRO_DRIFT_RATE_MAX - GYRO_DRIFT_RATE_MIN);

                
                gyroBaselineBeta += (latestBeta - gyroBaselineBeta) * driftRate;
                gyroBaselineGamma += (latestGamma - gyroBaselineGamma) * driftRate;

                
                currentRotateY = Math.max(-8, Math.min(8, relativeGamma * 0.35));
                currentRotateX = Math.max(-8, Math.min(8, relativeBeta * -0.35));

                scheduleTransformUpdate();
                gyroRafId = null;
            });
        }
    }

    function enableCardGyroscope() {
        window.addEventListener('deviceorientation', handleCardOrientation, { passive: true });
    }

    
    applyCardTransforms();

    
    postCards.forEach((card, index) => {
        let touchStartTime = 0;

        card.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            const focus = cardFocusValues[index];
            
            card.style.transition = 'transform 0.08s ease-out, box-shadow 0.08s ease-out';
            card.style.transform = `perspective(1000px) rotateX(0deg) rotateY(0deg) scale(${0.97 + focus * 0.01})`;
            card.style.boxShadow = `0 0.5px 1px rgba(0,0,0,0.2)`;
        }, { passive: true });

        card.addEventListener('touchend', () => {
            
            card.style.transition = 'transform 0.15s ease-out, box-shadow 0.15s ease-out';
            setTimeout(() => {
                card.style.transition = '';
                scheduleTransformUpdate();
            }, 150);
        }, { passive: true });

        card.addEventListener('touchcancel', () => {
            card.style.transition = '';
            scheduleTransformUpdate();
        }, { passive: true });
    });

    
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        
        enableCardGyroscope();

        
        const requestPermission = () => {
            if (cardGyroPermissionRequested) return;
            cardGyroPermissionRequested = true;

            DeviceOrientationEvent.requestPermission()
                .then(state => {
                    if (state === 'granted') {
                        enableCardGyroscope();
                    }
                })
                .catch(() => {
                    cardGyroPermissionRequested = false;
                });
        };
        document.addEventListener('touchstart', requestPermission, { once: true, passive: true });
        document.addEventListener('touchend', requestPermission, { once: true, passive: true });
        document.addEventListener('click', requestPermission, { once: true, passive: true });
    } else {
        
        enableCardGyroscope();
    }
} else {
    
    
    let currentMouseCard = null;
    let lastMouseX = 0, lastMouseY = 0;

    postCards.forEach(card => {
        let rafId = null;
        let isPressed = false;

        card.addEventListener('mouseenter', () => {
            currentMouseCard = card;
        });

        card.addEventListener('mousemove', (e) => {
            if (isPressed) return; 
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            if (!rafId) {
                rafId = requestAnimationFrame(() => {
                    if (isPressed) { rafId = null; return; }
                    const rect = card.getBoundingClientRect();
                    const mouseX = lastMouseX - rect.left;
                    const mouseY = lastMouseY - rect.top;
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const rotateX = (mouseY - centerY) / centerY * -CARD_CONFIG.maxRotation;
                    const rotateY = (mouseX - centerX) / centerX * CARD_CONFIG.maxRotation;
                    const normalizedY = (centerY - mouseY) / centerY;
                    const isDarkMode = document.body.classList.contains('dark');
                    const baseOpacity = isDarkMode ? CARD_CONFIG.shadowOpacityDark : CARD_CONFIG.shadowOpacityLight;
                    const shadowOpacity = Math.max(0, baseOpacity + normalizedY * CARD_CONFIG.shadowOpacityRange);
                    card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${CARD_CONFIG.hoverLift}px)`;
                    card.style.boxShadow = `0 ${CARD_CONFIG.shadowYOffsetHover}px ${CARD_CONFIG.shadowBlurHover}px rgba(0, 0, 0, ${shadowOpacity})`;
                    rafId = null;
                });
            }
        });

        card.addEventListener('mousedown', () => {
            isPressed = true;
            card.style.transform = 'scale(0.99)';
            card.style.boxShadow = '';
        });

        card.addEventListener('mouseup', () => {
            isPressed = false;
        });

        card.addEventListener('mouseleave', () => {
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
            isPressed = false;
            card.style.transform = '';
            card.style.boxShadow = '';
            currentMouseCard = null;
        });
    });

}

if (isHomePage) {
    
    setTimeout(triggerRandomScan, 3000 + Math.random() * 2000);
} else {
    
    setTimeout(() => {
        const logo = document.querySelector('.logo a');
        if (logo) scanElement(logo);

        setTimeout(() => {
            const titles = Array.from(document.querySelectorAll('.post-title'));
            if (titles.length > 0) {
                scanElement(titles[Math.floor(Math.random() * titles.length)]);
            }
            
            setTimeout(triggerRandomScan, 4000 + Math.random() * 6000);
        }, 400);
    }, 800);
}


const tocBox = document.querySelector('.toc');
if (tocBox) {
    const tocDetails = tocBox.querySelector('details');
    if (tocDetails) {
        tocBox.addEventListener('click', (e) => {
            
            if (e.target.tagName === 'A') return;
            
            if (e.target.closest('summary')) return;
            tocDetails.open = !tocDetails.open;
        });
    }
}
</script>
<div class="headerfooter">
    <sub><sup><sub>..</sub></sup></sub>
</div>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            document.documentElement.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            document.documentElement.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
